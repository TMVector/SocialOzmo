{"version":3,"sources":["..\\ozmo.fsx"],"names":[],"mappings":"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","file":"ozmo.js","sourcesContent":["(**\r\n - title: Ozmo game\r\n - tagline: Phil Trelford's classic ported to Fable\r\n - app-style: height:668px; width:900px; margin:20px auto 20px auto;\r\n - intro: Phil Trelford's [classic Ozmo game](https://twitter.com/ptrelford/status/475395178208174080), originally hosted\r\n   [on BitBucket](https://bitbucket.org/ptrelford/ozmo) ported to Fable! Shows how to handle keyboard events and\r\n   use HTML5 canvas. You can also get it (as a JavaScript app) from [the Windows\r\n   Store](https://www.microsoft.com/en-gb/store/apps/ozmo/9nblggh4rjng). View the [raw source code on\r\n   GitHub](https://github.com/fable-compiler/Fable/blob/master/samples/browser/ozmo/ozmo.fsx).\r\n   To play the game, use left and right keys!\r\n\r\n\r\n*)\r\n(*** hide ***)\r\n#r \"../../node_modules/fable-core/Fable.Core.dll\"\r\nopen Fable.Core\r\nopen Fable.Import\r\n\r\nmodule Keyboard =\r\n  let mutable keysPressed = Set.empty\r\n  let code x = if keysPressed.Contains(x) then 1 else 0\r\n  let arrows () = (code 39 - code 37, code 38 - code 40)\r\n  let update (e : Browser.KeyboardEvent, pressed) =\r\n    let keyCode = int e.keyCode\r\n    let op =  if pressed then Set.add else Set.remove\r\n    keysPressed <- op keyCode keysPressed\r\n    null\r\n  let init () =\r\n    Browser.window.addEventListener_keydown(fun e -> update(e, true))\r\n    Browser.window.addEventListener_keyup(fun e -> update(e, false))\r\n\r\n/// The width of the canvas\r\nlet width = 900.\r\n/// The height of the canvas\r\nlet height = 668.\r\n/// Height of the floor - the bottom black part\r\nlet floorHeight = 100.\r\n/// Height of the atmosphere - the yellow gradient\r\nlet atmosHeight = 300.\r\n\r\nKeyboard.init()\r\n\r\nlet canvas = Browser.document.getElementsByTagName_canvas().[0]\r\nlet ctx = canvas.getContext_2d()\r\ncanvas.width <- width\r\ncanvas.height <- height\r\n\r\n(**\r\nThis demo shows a simple game written using Fable and HTML5 canvas. One interesting\r\naspect of the game is the [asynchronous game loop](#Asynchronous-game-loop), which\r\nupdates the game state 60 times per second in a loop. This is implemented using F#\r\nasynchronous workflows, which make it possible to capture the logic as a recursive\r\nfunction, rather than using mutable state.\r\n\r\nThe Ozmo game uses the [Keyboard helpers from the Mario sample](../mario/index.html#Keyboard-helpers),\r\nso if you want to see those, check out the Mario sample first - it is also simpler,\r\nso you can check it out for lighter introduction to Fable and F#.\r\n\r\n## Drawing the world\r\n\r\nThe first few functions in the game deal with rendering. The world consists of two\r\ngradients (with yellow orange gradient in the sky and gray gradient for the atmosphere)\r\nand a filled black rectangle. The `drawGrd` function draws a gradient and `drawBg`\r\nrenders the world. We also need `drawText` for printing text when the game finishes:\r\n\r\n*)\r\n/// Draw gradient between two Y offsets and two colours\r\nlet drawGrd (ctx:Browser.CanvasRenderingContext2D)\r\n    (canvas:Browser.HTMLCanvasElement) (y0,y1) (c0,c1) =\r\n  let grd = ctx.createLinearGradient(0.,y0,0.,y1)\r\n  grd.addColorStop(0.,c0)\r\n  grd.addColorStop(1.,c1)\r\n  ctx.fillStyle <- U3.Case2 grd\r\n  ctx.fillRect(0.,y0, canvas.width, y1- y0)\r\n\r\n/// Draw background of the Ozmo game\r\nlet drawBg ctx canvas =\r\n  drawGrd ctx canvas\r\n    (0.,atmosHeight) (\"yellow\",\"orange\")\r\n  drawGrd ctx canvas\r\n    (atmosHeight, canvas.height-floorHeight)\r\n    (\"grey\",\"white\")\r\n  ctx.fillStyle <- U3.Case1 \"black\"\r\n  ctx.fillRect\r\n    ( 0.,canvas.height-floorHeight,\r\n      canvas.width,floorHeight )\r\n\r\n/// Draw the specified text (when game finishes)\r\nlet drawText(text,x,y) =\r\n  ctx.fillStyle <- U3.Case1 \"white\"\r\n  ctx.font <- \"bold 40pt\";\r\n  ctx.fillText(text, x, y)\r\n(**\r\n## Representing and drawing blobs\r\n\r\nEach of the balls in the game is represented by a `Blob` value that stores\r\nthe X and Y coordinates, size of the blob (radius), its colour and current speed.\r\nThe type is used for both falling blobs and for the player's blob:\r\n*)\r\ntype Blob =\r\n  { X:float; Y:float;\r\n    vx:float; vy:float;\r\n    Radius:float; color:string }\r\n(**\r\nDrawing blob on the canvas is quite easy - the following function does that using\r\nthe `arc` function of the 2D rendering context of the canvas:\r\n*)\r\nlet drawBlob (ctx:Browser.CanvasRenderingContext2D)\r\n    (canvas:Browser.HTMLCanvasElement) (blob:Blob) =\r\n  ctx.beginPath()\r\n  ctx.arc\r\n    ( blob.X, canvas.height - (blob.Y + floorHeight + blob.Radius),\r\n      blob.Radius, 0., 2. * System.Math.PI, false )\r\n  ctx.fillStyle <- U3.Case1 blob.color\r\n  ctx.fill()\r\n  ctx.lineWidth <- 3.\r\n  ctx.strokeStyle <- U3.Case1 blob.color\r\n  ctx.stroke()\r\n(**\r\n\r\n## Falling blobs and collisions\r\n\r\nThe next step is to define the physics for the game. This consists of several\r\nfunctions that update the `Blob` objects and are composed to apply all rules of\r\nphysics in the main game loop.\r\n*)\r\n/// Apply key effects on Player's blob - changes X speed\r\nlet direct (dx,dy) (blob:Blob) =\r\n  { blob with vx = blob.vx + (float dx)/4.0 }\r\n\r\n/// Apply gravity on falling blobs - gets faster every step\r\nlet gravity (blob:Blob) =\r\n  if blob.Y > 0. then { blob with vy = blob.vy - 0.1 }\r\n  else blob\r\n\r\n/// Bounde Player's blob off the wall if it hits it\r\nlet bounce (blob:Blob) =\r\n  let n = width\r\n  if blob.X < 0. then\r\n    { blob with X = -blob.X; vx = -blob.vx }\r\n  elif (blob.X > n) then\r\n    { blob with X = n - (blob.X - n); vx = -blob.vx }\r\n  else blob\r\n\r\n/// Move blob by one step - adds X and Y\r\n/// velocities to the X and Y coordinates\r\nlet move (blob:Blob) =\r\n  { blob with\r\n      X = blob.X + blob.vx\r\n      Y = max 0.0 (blob.Y + blob.vy) }\r\n(**\r\nThe above functions capture the individual aspects of the movement. The\r\nfollowing put everything together and handle steps of Player's blob and\r\nalso collision detection.\r\n*)\r\n/// Apply step on Player's blob. Composes above functions.\r\nlet step dir blob =\r\n  blob |> direct dir |> move |> bounce\r\n\r\n/// Check whether two blobs collide\r\nlet collide (a:Blob) (b:Blob) =\r\n  let dx = (a.X - b.X)*(a.X - b.X)\r\n  let dy = (a.Y - b.Y)*(a.Y - b.Y)\r\n  let dist = sqrt(dx + dy)\r\n  dist < abs(a.Radius - b.Radius)\r\n\r\n/// Remove all falling blobs that hit Player's blob\r\nlet absorb (blob:Blob) (drops:Blob list) =\r\n  drops |> List.filter (fun drop ->\r\n    collide blob drop |> not )\r\n(**\r\n## Game logic helpers\r\n\r\nNext, we define a couple of helpers for generating and updating the falling blobs.\r\nWe have black growing blobs and white shrinking blobs. The `newGrow` and `newShrink`\r\nfunctions are used to generate new blobs:\r\n*)\r\nlet grow = \"black\"\r\nlet shrink = \"white\"\r\n\r\nlet newDrop color =\r\n  { X = JS.Math.random()*width*0.8 + (width*0.1)\r\n    Y=600.; Radius=10.; vx=0.; vy = 0.0\r\n    color=color }\r\n\r\nlet newGrow () = newDrop grow\r\nlet newShrink () = newDrop shrink\r\n(**\r\nInside the game loop, we will generate blobs randomly, but we keep a counter of\r\nticks to make sure that we do not generate new blobs too often. The `updateDrops`\r\nfunction takes current drops and a countdown and returns a pair with new drops and\r\na new countdown. It implements simple logic:\r\n\r\n - If we generated drop in last 8 steps, do nothing and decrement counter\r\n - Roll an 8 sided dice and if we get 1, generate new blob\r\n   (2/3 are shrinkind and 1/3 are growing)\r\n - Otherwise, do nothing and return previous state\r\n\r\n*)\r\n/// Update drops and countdown in each step\r\nlet updateDrops drops countdown =\r\n  if countdown > 0 then\r\n    drops, countdown - 1\r\n  elif floor(JS.Math.random()*8.) = 0. then\r\n    let drop =\r\n      if floor(JS.Math.random()*3.) = 0. then newGrow()\r\n      else newShrink()\r\n    drop::drops, 8\r\n  else drops, countdown\r\n\r\n/// Count growing and shrinking drops in the list\r\nlet countDrops drops =\r\n  let count color =\r\n    drops\r\n    |> List.filter (fun drop -> drop.color = color)\r\n    |> List.length\r\n  count grow, count shrink\r\n\r\n(**\r\n## Asynchronous game loop\r\n\r\nThe asynchronous game loop is perhaps the most interesting part of the source code.\r\nFable supports F# asynchronous workflows, which give us a way to write non-blocking loop\r\nthat includes sleeping in the middle, so you can write long-running processes as a recursive\r\nloop rather than using timers and callbacks.\r\n\r\nThe following diagram illustrates the game loop:\r\n\r\n    [lang=text]\r\n    (start)        +----(tick)---+\r\n       \\           |             |\r\n         +------+  |  +--------+ |   +-----------+\r\n      +->| game |--+->| update |-+-->| completed |<-+\r\n      |  +------+     +--------+     +-----------+  |\r\n      |                                             |\r\n      +-----------(after 10 seconds)----------------+\r\n\r\nThere are three states in which the game can be:\r\n\r\n - After starting, the `game` state initializes the Player's blob and starts the game\r\n - The `update` loop is active when the game is running. It calls itself recursively\r\n   until the game ends.\r\n - After finishing, the `completed` state displays a message and sleeps for 10 seconds\r\n   before starting a new game.\r\n\r\nUsing asynchronous workflows, the state machine can be represented using 3 mutually\r\nrecursive functions, each representing one of the states. The `game` and `completed`\r\nstates are simple:\r\n*)\r\n/// Starts a new game\r\nlet rec game () = async {\r\n  let blob =\r\n    { X = 300.; Y=0.; Radius=50.;\r\n      vx=0.; vy=0.; color=\"black\" }\r\n  return! update blob [newGrow ()] 0 }\r\n\r\n/// Displays message and sleeps for 10 sec\r\nand completed () = async {\r\n  drawText (\"COMPLETED\",320.,300.)\r\n  do! Async.Sleep 10000\r\n  return! game () }\r\n(**\r\nNote that we are using `let rec .. and`, which lets us write multiple recursive functions\r\nthat can call each other. The `completed` function calls `game` after 10 seconds using\r\n`return!` (representing an asynchronous tail-call) and the `game` function calls `update`\r\nwith the initial state. The `update` loop looks as follows:\r\n*)\r\n/// Keeps current state for Player's blob, falling\r\n/// drops and the countdown since last drop was generated\r\nand update blob drops countdown = async {\r\n  // Update the drops & countdown\r\n  let drops, countdown = updateDrops drops countdown\r\n\r\n  // Count drops, apply physics and count them again\r\n  let beforeGrow, beforeShrink = countDrops drops\r\n  let drops =\r\n    drops\r\n    |> List.map (gravity >> move)\r\n    |> absorb blob\r\n  let afterGrow, afterShrink = countDrops drops\r\n  let drops = drops |> List.filter (fun blob -> blob.Y > 0.)\r\n\r\n  // Calculate new player's size based on absorbed drops\r\n  let radius = blob.Radius + float (beforeGrow - afterGrow) *4.\r\n  let radius = radius - float (beforeShrink - afterShrink) * 4.\r\n  let radius = max 5.0 radius\r\n\r\n  // Update radius and apply keyboard events\r\n  let blob = { blob with Radius = radius }\r\n  let blob = blob |> step (Keyboard.arrows())\r\n\r\n  // Render the new game state\r\n  drawBg ctx canvas\r\n  for drop in drops do drawBlob ctx canvas drop\r\n  drawBlob ctx canvas blob\r\n\r\n  // If the game completed, switch state\r\n  // otherwise sleep and update recursively!\r\n  if blob.Radius > 150. then\r\n    return! completed()\r\n  else\r\n    do! Async.Sleep(int (1000. / 60.))\r\n    return! update blob drops countdown }\r\n(**\r\nThe last thing that we need to do is to start the game in the initial `game`\r\nstate using `Async.StartImmediate`:\r\n*)\r\ngame () |> Async.StartImmediate\r\n\r\n\r\n\r\n#r \"../../node_modules/fable-core/Fable.Core.dll\"\r\n#r \"../../node_modules/fable-powerpack/Fable.PowerPack.dll\"\r\n#I __SOURCE_DIRECTORY__\r\n#load \"pusher.fs\"\r\nopen Fable.Import\r\nopen Fable.Core.JsInterop\r\nopen G.PusherPlatform\r\nopen Fable.PowerPack\r\n\r\n// Set up app\r\nlet appId = \"e7861df8-5d11-462b-acb2-19a72a5335de\"\r\nlet pusher = App(AppOptions(appId))\r\n\r\n// Subscribe to a feed\r\nlet feed = pusher.feed(\"playground\")\r\nlet sub =\r\n    feed.subscribe(\r\n        FeedSubscribeOptions(\r\n            onOpen = (fun () -> Browser.console.log(\"Connection established\")),\r\n            onItem = (fun item -> Browser.console.log(\"Item: \", item)),\r\n            onError = (fun error -> Browser.console.log(\"Error: \", error))))\r\n\r\n// Append items to the feed\r\nfeed.append(\"Hello, world!\")\r\n|> Promise.bind (fun response -> Browser.console.log(\"Success:\", response); Promise.lift())\r\n|> Promise.catch (fun err -> Browser.console.error(\"Error:\", err))\r\n|> ignore\r\n    \r\n// Youï¿½re not limited to appending string values;\r\n// you can also append objects, arrays and numbers.\r\nfeed.append(createObj [ \"yourKey\" ==> \"your value\" ])\r\n|> Promise.bind (fun response -> Browser.console.log(\"Success:\", response); Promise.lift())\r\n|> Promise.catch (fun err -> Browser.console.error(\"Error:\", err))\r\n|> ignore\r\n"]}